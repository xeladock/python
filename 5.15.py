# Finite
# simple
# continued
# fraction(wiki) -− это
# дробь
# вида
#
# a_0 + \dfrac1
# {a_1 + \dfrac1
# {a_2 + \dfrac1
# {\ddots + \dfrac1
# {a_n}}}}a
# 0
# ​
# +
# a
# 1
# ​
# +
# a
# 2
# ​
# +
# ⋱+
# a
# n
# ​
#
# 1
# ​
#
# 1
# ​
#
# 1
# ​
#
# 1
# ​
#
#
# Известно, что
# любую
# обыкновенную
# дробь
# можно
# записать
# в
# виде
# конечной
# простой
# непрерывной
# дроби.
#
# Напишите
# программу, которая
# преобразует
# обыкновенную
# дробь
# в
# последовательность
# коэффициентов
# a_0, a_1, \ldots, a_na
# 0
# ​
# , a
# 1
# ​
# , …, a
# n
# ​
# .
#
# Например, дроби
# 239 / 30239 / 30
# будет
# соответствовать
# непрерывная
# дробь
#
# 7 + \dfrac1
# {1 + \dfrac1
# {29}}7 +
# 1 +
# 29
# 1
# ​
#
# 1
# ​
#
#
# соответственно, коэффициенты
# будут
# равны
# 7, 1
# и
# 29.
#
# Формат
# ввода:
# Строка, содержащая
# обыкновенную
# дробь
# в
# формате
# числитель / знаменатель.
#
# Формат
# вывода:
# Строка
# с
# последовательностью
# коэффициентов, записанных
# через
# пробел.
#
# Sample
# Input:
#
# 239/30
# Sample
# Output:
#
# 7 1 29


# https://stepik.org/lesson/22418/step/1?adaptive=true&unit=5333
import re
# b=input()
# a=re.split('(\d+)',input())
a = list(map(int,(re.sub('[^0-9]', ' ', input()).split())))
z=[]
if a[0]<a[1]:
    z.append(0)
    a[0], a[1] = a[1], a[0]
    z.append(max(a[0],a[1])//min(a[0],a[1]))
else:
    z = [max(a) // min(a)]

while a[0]>=1 and a[1]>=1:
    s=[]
    a[0],a[1]=a[1],a[0]%a[1]
    s=[a[0],a[1]]
    if 0 in s: print(*z); exit()
    z.append(max(s)//min(s))
print(*z)